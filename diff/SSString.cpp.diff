--- spal60sr\src\TSSGCtrl\SSString.original.cpp	Sun Apr  6 21:44:36 2003
+++ spal60sr\src\TSSGCtrl\SSString.cpp.txt	Sun Apr  6 21:44:36 2003
@@ -1,5 +1,13 @@
 #include "SSString.h"
 
+#define LOCAL_MEMORY_SUPPORT 1
+#define FIX_ADJUST_BY_STRING 1
+#define FORCE_FUNNEL         1
+
+#if UNICODE_SUPPORT
+#include "intrinsic.h"
+#endif
+
 //---------------------------------------------------------------------
 //「初期設定関数」
 //
@@ -18,6 +26,16 @@
  size = TStringDivision::ToULongDef(tmpV[1]);
  endWord = (tmpV[2]=="null")? (string)"00" : tmpV[2];
 
+#if UNICODE_SUPPORT
+ isUnicode = (endWord.length() == 7 &&
+	*(LPDWORD) endWord.c_str()      == BSWAP32('unic') &&
+	*(LPDWORD)(endWord.c_str() + 4) == BSWAP32('ode\0'));
+ if (isUnicode)
+ {
+	endWord = "0000";
+	size &= -2;
+ }
+#endif
 
  //名称も切り分ける
  SSGC.strD.List(name, "/", &tmpV, strD::dtESCAPE+strD::etREPLACE+strD::etTRIM);
@@ -35,6 +53,29 @@
 //	・TSSArg *Argに、所得したデータが入ります。
 //	・TSSArgとして渡すポインタは、TSSArgStringクラスであること。
 //---------------------------------------------------------------------
+#if UNICODE_SUPPORT
+void __stdcall TSSString_Read_UnicodeString(TSSString *_this, unsigned long size, string &Data, char *tmpC)
+{
+	if (_this->isUnicode)
+	{
+		Data.resize(size);
+		int cchMultiByte =
+			WideCharToMultiByte(
+				CP_THREAD_ACP,
+				0,
+				(LPCWSTR)tmpC,
+				-1,
+				Data.begin(),
+				size + 1,
+				NULL,
+				NULL);
+		if (cchMultiByte != 0)
+			cchMultiByte--;
+		Data.resize(cchMultiByte);
+	}
+}
+//---------------------------------------------------------------------
+#endif
 unsigned long TSSString::Read(TSSGCtrl &SSGC, TSSArg *Arg)
 {
  if((Arg==NULL) || (Arg->GetType()!=ssgCtrl::atSTRING) )
@@ -43,28 +84,52 @@
  Setting(SSGC);
 
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ) )==NULL)
+#else
+ if ((SHandle = SSGC.Open(this, PROCESS_VM_READ, addressStr.c_str())) == NULL)
+#endif
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
 
+#if !SUBJECT_STATUS
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#else
+ if(!SSGC.IsEnabled(this, TRUE)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#endif
 
 
  //属性を適用
  unsigned long Address = SSGC.GetAddress(this, addressStr);
+#if SUBJECT_STATUS
+ address = (const BYTE *)Address;
+#endif
 
+#if !UNICODE_SUPPORT
  char *tmpC = new char[size+1];
  tmpC[size] = (char)NULL;
+#else
+ char *tmpC = new char[size + 2];
+ *(LPWSTR)&tmpC[size] = L'\0';
+#endif
 
  if(!SSGC.OneRead(this, SHandle, Address, tmpC, size)){
     delete[] tmpC;
  	return ssgCtrl::reACCESS_ERROR; //エラーならssgCtrl::reACCESS_ERRORを返す
  }
  string Data(tmpC);
+#if UNICODE_SUPPORT
+ TSSString_Read_UnicodeString(size, endWord, Data, tmpC);
+#endif
  delete[] tmpC;
 
  if((!endWord.empty())&&(endWord!="00")){
 	unsigned long Pos = SSGC.strD.Find(Data, SSGC.GetSimpleByteCode(this, endWord));
+#if !UNICODE_SUPPORT
 	if((size_t)Pos != string::npos) Data[Pos]=(byte)NULL;
+#else
+	if ((size_t)Pos != string::npos && !isUnicode)
+		Data.resize(Pos);
+#endif
  }
 
  ((TSSArgString*)Arg)->SetValue( Data );
@@ -85,7 +150,11 @@
  Setting(SSGC);
 
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ|PROCESS_VM_WRITE|PROCESS_VM_OPERATION) )==NULL)
+#else
+ if ((SHandle = SSGC.Open(this, PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, addressStr.c_str())) == NULL)
+#endif
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
 
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
@@ -93,10 +162,30 @@
 
  //属性を適用
  unsigned long Address = SSGC.GetAddress(this, addressStr);
+#if SUBJECT_STATUS
+ address = (const BYTE *)Address;
+#endif
 
  string Str( ((TSSArgString*)Arg)->GetValue() );
  string WriteString;
+#if !UNICODE_SUPPORT
  WriteString.reserve( Str.size()*2 + endWord.size() );
+#else
+ size_t n = Str.size() * 2 + endWord.size();
+ WriteString.reserve(n);
+ if (isUnicode)
+ {
+	size_t unicodeSize = MultiByteToWideChar(
+		CP_THREAD_ACP,
+		0,
+		Str.c_str(),
+		Str.length(),
+		(LPWSTR)WriteString.begin(),
+		n / 2) * 2;
+	Str = string(WriteString.c_str(), min(unicodeSize, size));
+	WriteString.clear();
+ }
+#endif
  {//書きたい文字列を、バイト列に変換
 	string::iterator 
 		SIt = Str.begin(),
@@ -112,8 +201,27 @@
  TSmartVector<TProcessAccessElementBase> CompareVec
  		= SSGC.StrToProcessAccessElementVec(this, WriteString);
 
+#if !FORCE_FUNNEL
  return (SSGC.Write(this, SHandle, &Address, *CompareVec.GetData())==0) ? ssgCtrl::reNO_ERROR : ssgCtrl::reACCESS_ERROR;
  	//エラーならssgCtrl::reACCESS_ERRORを返す
+#else
+ if (SSGC.Write(this, SHandle, &Address, *CompareVec.GetData()) != 0)
+ {
+	// エラーならssgCtrl::reACCESS_ERRORを返す
+	return ssgCtrl::reACCESS_ERROR;
+ }
+ else
+ {
+	size_t length = WriteString.length();
+	unsigned long Val =
+		(length >  2) ? *(LPDWORD)WriteString.begin() :
+		(length == 2) ? *(LPWORD )WriteString.begin() :
+		(length != 0) ? *(LPBYTE )WriteString.begin() :
+		0;
+	SSGC.CheckFunnel(this, Val);
+	return ssgCtrl::reNO_ERROR;
+ }
+#endif
 
 }
 //---------------------------------------------------------------------
@@ -131,9 +239,27 @@
  string Val = ((TSSArgString*)Arg)->GetValue();
  string tmpS;
  tmpS.reserve(size*2);
+#if UNICODE_SUPPORT
+ if (isUnicode)
+ {
+	size_t unicodeSize = MultiByteToWideChar(
+		CP_THREAD_ACP,
+		0,
+		Val.c_str(),
+		Val.length(),
+		(LPWSTR)tmpS.begin(),
+		size) * 2;
+	Val = string(tmpS.c_str(), min(unicodeSize, size));
+	tmpS.clear();
+ }
+#endif
 
  unsigned long i=0, End=Val.size();
+#if #if !FIX_ADJUST_BY_STRING
  for(; i<End; i++) tmpS += TStringDivision::ToString((char)Val[i], "%02X");
+#else
+ for(; i<End; i++) tmpS += TStringDivision::ToString((unsigned char)Val[i], "%02X");
+#endif
  
  if((size -End) != 0){
 	tmpS += "*+04";
