--- spal60sr\src\gui\MainUnit.original.cpp	Wed May 28 20:22:00 2003
+++ spal60sr\src\gui\MainUnit.cpp	Wed May 28 20:22:00 2003
@@ -34,6 +34,43 @@
 #include "SSSplit.h"
 #include "SSGLoadSettingListner.h";
 
+#define FIX_CHANGE_SUBJECT_PANEL 1
+#define FIX_MOUSE_WHEEL          1
+#define FIX_SUBJECT_ACCESS       1
+#define SHOW_ERROR_MESSAGE       1
+#define COMMON_LIST              1
+
+#if defined(FIX_DGRID) && FIX_DGRID
+#include <windowsx.h>
+#include <assert.h>
+#include "WaitCursor.h"
+#include "SSGSubjectProperty.h"
+#endif
+
+#if defined(FIX_USERMODE) && FIX_USERMODE
+#include <stdlib.h>
+#ifndef _countof
+#define _countof(_Array) (sizeof(_Array) / sizeof((_Array)[0]))
+#endif
+#include "intrinsic.h"
+EXTERN_C unsigned __int64 __cdecl _strtoui64(const char *nptr, char **endptr, int base);
+#define _ultoa ultoa
+#endif
+
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+#include "ErrorMessage.h"
+#endif
+
+#if defined(PROCESS_MONITOR) && PROCESS_MONITOR
+#include "ProcessMonitor.h"
+#endif
+
+#if defined(OPTIMIZE_GUIDE) && OPTIMIZE_GUIDE
+#include "ApplicationMessage.h"
+void __cdecl ClearGuideBuffer();
+LRESULT __stdcall DrawGuideBuffer(WNDPROC lpPrevWndFunc, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+#endif
+
 #ifdef USE_GLDPNGHPP
 #include "GLDPNG.hpp"
 #endif
@@ -41,11 +78,471 @@
 #pragma package(smart_init)
 #pragma resource "*.dfm"
 TMainForm *MainForm;
+
+#if defined(FIX_USERMODE) && FIX_USERMODE
+WORD wBegginerModeId;
+WORD wDebuggerModeId;
+WORD wMaxMenuId;
+WORD wDebugWithoutMouseOverModeId;
+WORD wToolMenuId;
+char lpMenuProfileName[MAX_PATH] = { '\0' };
+//---------------------------------------------------------------------------
+UINT __stdcall GetMaxMenuItemId(HMENU hMenu, UINT uMaxMenuId)
+{
+	MENUITEMINFOA mii;
+	UINT          uCount;
+	UINT          uItem;
+
+	uCount = ::GetMenuItemCount(hMenu);
+	mii.cbSize = sizeof(mii);
+	mii.fMask = MIIM_SUBMENU;
+	for (uItem = 0; uItem < uCount; uItem++)
+	{
+		UINT uItemId;
+
+		uItemId = ::GetMenuItemID(hMenu, uItem);
+		if (uItemId != UINT_MAX && uMaxMenuId < uItemId)
+			uMaxMenuId = uItemId;
+		if (!::GetMenuItemInfoA(hMenu, uItem, TRUE, &mii))
+			continue;
+		if (!mii.hSubMenu)
+			continue;
+		uMaxMenuId = GetMaxMenuItemId(mii.hSubMenu, uMaxMenuId);
+	}
+	return uMaxMenuId;
+}
+//---------------------------------------------------------------------------
+void __stdcall InitializeMenuId()
+{
+	HMENU userModeHandle;
+
+	userModeHandle = MainForm->M_UserMode->Handle;
+	wBegginerModeId = ::GetMenuItemID(userModeHandle, 0);
+	wDebuggerModeId = ::GetMenuItemID(userModeHandle, 3);
+	wMaxMenuId = GetMaxMenuItemId(MainForm->MainMenu1->Handle, 0);
+}
+//---------------------------------------------------------------------------
+BOOL __stdcall AppendDebugWithoutMouseOverModeMenu()
+{
+	HMENU         userModeHandle;
+	MENUITEMINFOA mii;
+
+	wDebugWithoutMouseOverModeId = ++wMaxMenuId;
+	mii.cbSize = sizeof(mii);
+	mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
+	mii.fType = MFT_STRING | MFT_RADIOCHECK;
+	mii.fMask = MIIM_ID | MIIM_TYPE;
+	mii.wID = wDebugWithoutMouseOverModeId;
+	mii.dwTypeData = "SSGデバッグモード - マウスオーバーを除く (&4)";
+	mii.cch = 49;
+	return ::InsertMenuItemA(MainForm->M_UserMode->Handle, 4, TRUE, &mii);
+}
+//---------------------------------------------------------------------------
+BOOL __stdcall AppendToolMenu()
+{
+	UINT          uItem;
+	MENUITEMINFOA mii;
+	char          lpKeyName[16];
+	char          lpMenuString[MAX_PATH];
+	HMENU         hPopupMenu;
+	HMENU         hMenu;
+
+	uItem = 0;
+	mii.cch = ::GetPrivateProfileStringA("MenuString", _ultoa(uItem, lpKeyName, 10), "", lpMenuString, _countof(lpMenuString), lpMenuProfileName);
+	if (mii.cch == 0)
+		goto SUCCESS;
+	hPopupMenu = ::CreatePopupMenu();
+	if (hPopupMenu == NULL)
+		goto FAILED1;
+	mii.cbSize = sizeof(mii);
+	mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
+	mii.fType = MFT_STRING;
+	mii.fMask = MIIM_ID | MIIM_TYPE;
+	mii.wID = wToolMenuId = wMaxMenuId + 1;
+	mii.dwTypeData = lpMenuString;
+	for (; ; )
+	{
+		if (!::InsertMenuItemA(hPopupMenu, uItem, TRUE, &mii))
+			goto FAILED2;
+		mii.cch = ::GetPrivateProfileStringA("MenuString", _ultoa(++uItem, lpKeyName, 10), "", lpMenuString, _countof(lpMenuString), lpMenuProfileName);
+		if (mii.cch == 0)
+			break;
+		mii.wID++;
+	}
+	hMenu = MainForm->MainMenu1->Handle;
+	if (hMenu == NULL)
+		goto FAILED2;
+	mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
+	mii.hSubMenu = hPopupMenu;
+	mii.dwTypeData = "ツール(&T)";
+	mii.cch = 10;
+	if (!::InsertMenuItemA(hMenu, 4, TRUE, &mii))
+		goto FAILED2;
+	wMaxMenuId = mii.wID;
+SUCCESS:
+	return TRUE;
+
+FAILED2:
+	::DestroyMenu(hPopupMenu);
+FAILED1:
+	return FALSE;
+}
+//---------------------------------------------------------------------------
+void __cdecl UpdateUserModeMenu()
+{
+	HMENU         hMenu;
+	MENUITEMINFOA mii;
+
+	hMenu = MainForm->M_UserMode->Handle;
+	mii.cbSize = sizeof(mii);
+	mii.fMask = MIIM_STATE;
+	mii.fState = MFS_UNCHECKED;
+	if (MainForm->GetUserMode() == 4)
+	{
+		::SetMenuItemInfoA(hMenu, 0, TRUE, &mii);
+		::SetMenuItemInfoA(hMenu, 1, TRUE, &mii);
+		::SetMenuItemInfoA(hMenu, 2, TRUE, &mii);
+		::SetMenuItemInfoA(hMenu, 3, TRUE, &mii);
+	}
+	else
+	{
+		::SetMenuItemInfoA(hMenu, 4, TRUE, &mii);
+	}
+	mii.fState = MFS_CHECKED;
+	::SetMenuItemInfoA(hMenu, MainForm->GetUserMode(), TRUE, &mii);
+}
+//---------------------------------------------------------------------------
+void __stdcall TMainForm_OnCommand(HWND hWnd, WORD wNotifyCode, WORD wID, HWND hwndCtl)
+{
+	if (wNotifyCode != 0 || wID > wMaxMenuId)
+		return;
+	if (wID >= wBegginerModeId && wID <= wDebuggerModeId)
+	{
+		if (MainForm->GetUserMode() != 4)
+			return;
+		MainForm->SetUserMode(wID - wBegginerModeId);
+		UpdateUserModeMenu();
+		if (MainForm->guideForm != NULL)
+			MainForm->guideForm->UserModeCmbBox->ItemIndex = MainForm->GetUserMode();
+	}
+	else if (wID == wDebugWithoutMouseOverModeId)
+	{
+		if (MainForm->GetUserMode() == 4)
+			return;
+		MainForm->SetUserMode(4);
+		UpdateUserModeMenu();
+		if (MainForm->guideForm != NULL)
+			MainForm->guideForm->UserModeCmbBox->ItemIndex = MainForm->GetUserMode();
+	}
+	else if (wID >= wToolMenuId)
+	{
+		char lpKeyName   [16];
+		char lpOperation [MAX_PATH];
+		char lpFile      [MAX_PATH];
+		char lpParameters[MAX_PATH];
+		char lpDirectory [MAX_PATH];
+		char lpShowCmd   [20];
+		char *p;
+		UINT nShowCmd;
+
+		_ultoa(wID - wToolMenuId, lpKeyName, 10);
+		::GetPrivateProfileStringA("Operation" , lpKeyName, "", lpOperation , _countof(lpOperation ), lpMenuProfileName);
+		::GetPrivateProfileStringA("File"      , lpKeyName, "", lpFile      , _countof(lpFile      ), lpMenuProfileName);
+		::GetPrivateProfileStringA("Parameters", lpKeyName, "", lpParameters, _countof(lpParameters), lpMenuProfileName);
+		::GetPrivateProfileStringA("Directory" , lpKeyName, "", lpDirectory , _countof(lpDirectory ), lpMenuProfileName);
+		::GetPrivateProfileStringA("ShowCmd"   , lpKeyName, "", lpShowCmd   , _countof(lpShowCmd   ), lpMenuProfileName);
+		for (p = lpShowCmd; *p != '\0'; p++)
+			*p = __intrinsic_toupper(*p);
+		do
+		{
+			unsigned __int64 ull;
+			char             *endptr;
+
+			if (*(LPDWORD)lpShowCmd == BSWAP32('SW_H'))
+			{
+				if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('IDE\0'))
+				{
+					nShowCmd = SW_HIDE;
+					break;
+				}
+			}
+			else if (*(LPDWORD)lpShowCmd == BSWAP32('SW_M'))
+			{
+				if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('IZE\0'))
+				{
+					if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('AXIM'))
+					{
+						nShowCmd = SW_MAXIMIZE;
+						break;
+					}
+					else if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('INIM'))
+					{
+						nShowCmd = SW_MINIMIZE;
+						break;
+					}
+				}
+			}
+			else if (*(LPDWORD)lpShowCmd == BSWAP32('SW_R'))
+			{
+				if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('ESTO') &&
+					(*(LPDWORD)(lpShowCmd + 8) & 0x00FFFFFF) == BSWAP24('RE\0'))
+				{
+					nShowCmd = SW_RESTORE;
+					break;
+				}
+			}
+			else if (*(LPDWORD)lpShowCmd == BSWAP32('SW_S'))
+			{
+				if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('HOW\0'))
+				{
+					nShowCmd = SW_SHOW;
+					break;
+				}
+				else if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('HOWD'))
+				{
+					if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('EFAU') &&
+						(*(LPDWORD)(lpShowCmd + 12) & 0x00FFFFFF) == BSWAP24('LT\0'))
+					{
+						nShowCmd = SW_SHOWDEFAULT;
+						break;
+					}
+				}
+				else if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('HOWM'))
+				{
+					if (*(LPDWORD)(lpShowCmd + 12) == BSWAP32('IZED'))
+					{
+						if (lpShowCmd[13] == '\0')
+						{
+							if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('AXIM'))
+							{
+								nShowCmd = SW_SHOWMAXIMIZED;
+								break;
+							}
+							else if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('INIM'))
+							{
+								nShowCmd = SW_SHOWMINIMIZED;
+								break;
+							}
+						}
+					}
+					else if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('INNO'))
+					{
+						if (*(LPDWORD)(lpShowCmd + 12) == BSWAP32('ACTI') &&
+							(*(LPDWORD)(lpShowCmd + 16) & 0x00FFFFFF) == BSWAP24('VE\0'))
+						{
+							nShowCmd = SW_SHOWMINNOACTIVE;
+							break;
+						}
+					}
+				}
+				else if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('HOWN'))
+				{
+					if (*(LPWORD)(lpShowCmd + 8) == BSWAP16('A\0'))
+					{
+						nShowCmd = SW_SHOWMINNOACTIVE;
+						break;
+					}
+					else if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('OACT'))
+					{
+						if (*(LPDWORD)(lpShowCmd + 12) == BSWAP32('IVAT') &&
+							*(LPWORD)(lpShowCmd + 16) == BSWAP16('E\0'))
+						{
+							nShowCmd = SW_SHOWNOACTIVATE;
+							break;
+						}
+					}
+					else if (*(LPDWORD)(lpShowCmd + 8) == BSWAP32('ORMA'))
+					{
+						if (*(LPWORD)(lpShowCmd + 12) == BSWAP16('L\0'))
+						{
+							nShowCmd = SW_SHOWNORMAL;
+							break;
+						}
+					}
+				}
+			}
+			else if (*(LPDWORD)lpShowCmd == BSWAP32('SW_F'))
+			{
+				if (*(LPDWORD)(lpShowCmd + 4) == BSWAP32('ORCE') &&
+					*(LPDWORD)(lpShowCmd + 8) == BSWAP32('MINI') &&
+					*(LPDWORD)(lpShowCmd + 12) == BSWAP32('MIZE') &&
+					lpShowCmd[16] == '\0')
+				{
+					nShowCmd = SW_FORCEMINIMIZE;
+					break;
+				}
+			}
+			ull = _strtoui64(lpShowCmd, &endptr, 0);
+			if (ull <= SW_MAX && *endptr == '\0')
+				nShowCmd = (UINT)ull;
+			else
+				nShowCmd = SW_SHOWNORMAL;
+		} while (0);
+		::ShellExecuteA(hWnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
+	}
+}
+//---------------------------------------------------------------------------
+WNDPROC TMainForm_PrevWindowProc = NULL;
+LRESULT CALLBACK TMainForm_WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	if (uMsg == WM_COMMAND)
+		TMainForm_OnCommand(hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
+#if defined(OPTIMIZE_GUIDE) && OPTIMIZE_GUIDE
+	else if (uMsg == WM_DRAW_GUIDE_BUFFER)
+		return DrawGuideBuffer(TMainForm_PrevWindowProc, hwnd, uMsg, wParam, lParam);
+#endif
+	return ::CallWindowProcA((FARPROC)TMainForm_PrevWindowProc, hwnd, uMsg, wParam, lParam);
+}
+#endif
+#if defined(FIX_DGRID) && FIX_DGRID
+//---------------------------------------------------------------------------
+WNDPROC TMainForm_PrevDGridProc = NULL;
+LRESULT CALLBACK TMainForm_DGridProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	if (uMsg == WM_MOUSEWHEEL)
+	{
+		TShiftState Shift;
+		TPoint      MousePos;
+		bool        Handled;
+
+		// after dragging a vertical scroll box.
+		if (LOWORD(wParam) & MK_LBUTTON)
+			Shift << ssLeft;
+		if (LOWORD(wParam) & MK_RBUTTON)
+			Shift << ssRight;
+		if (LOWORD(wParam) & MK_SHIFT)
+			Shift << ssShift;
+		if (LOWORD(wParam) & MK_CONTROL)
+			Shift << ssCtrl;
+		if (LOWORD(wParam) & MK_MBUTTON)
+			Shift << ssMiddle;
+		MousePos.x = GET_X_LPARAM(lParam);
+		MousePos.y = GET_Y_LPARAM(lParam);
+		Handled = false;
+		MainForm->FormMouseWheel(
+			MainForm->DGrid,
+			Shift,
+			GET_WHEEL_DELTA_WPARAM(wParam),
+			MousePos,
+			Handled);
+		return 0;
+	}
+	else if (uMsg == WM_KEYDOWN)
+	{
+		TShiftState Shift;
+
+		// after dragging a vertical scroll box.
+		MainForm->HotKeyEditKeyDown(MainForm->DGrid, *(LPWORD)&wParam, Shift);
+		return 0;
+	}
+	else if (uMsg == WM_HSCROLL)
+	{
+		WORD wScrollCode;
+
+		wScrollCode = LOWORD(wParam);
+		if (wScrollCode == SB_PAGELEFT || wScrollCode == SB_PAGERIGHT)
+		{
+			SCROLLINFO si;
+
+			si.cbSize = sizeof(SCROLLINFO);
+			si.fMask = SIF_RANGE | SIF_POS;
+			if (::GetScrollInfo(hwnd, SB_HORZ, &si))
+			{
+				int range;
+
+				range = si.nMax - si.nMin;
+				if (range)
+				{
+					int clientWidth;
+
+					clientWidth = MainForm->DGrid->ClientWidth;
+					if (MainForm->DGrid->DefaultColWidth > clientWidth)
+					{
+						int page;
+
+						page = ::MulDiv(clientWidth, range, MainForm->DGrid->DefaultColWidth - clientWidth);
+						if (wScrollCode == SB_PAGELEFT)
+						{
+							si.nPos -= page;
+							if (si.nPos < si.nMin)
+								si.nPos = si.nMin;
+						}
+						else
+						{
+							si.nPos += page;
+							if (si.nPos > si.nMax)
+								si.nPos = si.nMax;
+						}
+						wParam = MAKEWPARAM(SB_THUMBTRACK, si.nPos);
+					}
+				}
+			}
+		}
+	}
+	return ::CallWindowProcA((FARPROC)TMainForm_PrevDGridProc, hwnd, uMsg, wParam, lParam);
+}
+#endif
 //---------------------------------------------------------------------------
 __fastcall TMainForm::TMainForm(TComponent* Owner)
     : TForm(Owner)
 {
+#if defined(PROCESS_MONITOR) && PROCESS_MONITOR
+	InitializeProcessMonitor();
+#endif
+
+#if defined(FIX_USERMODE) && FIX_USERMODE
+	char *delimiter, *p, c;
+
+	::GetModuleFileNameA(NULL, lpMenuProfileName, _countof(lpMenuProfileName));
+	delimiter = NULL;
+	for (p = lpMenuProfileName; c = *p; p++)
+		if (c == '\\' || c == '/')
+			delimiter = p;
+	p = delimiter ? delimiter + 1 : lpMenuProfileName;
+	p[0] = 'm';
+	p[1] = 'e';
+	p[2] = 'n';
+	p[3] = 'u';
+	p[4] = '.';
+	p[5] = 'i';
+	p[6] = 'n';
+	p[7] = 'i';
+	p[8] = '\0';
+	InitializeMenuId();
+	AppendDebugWithoutMouseOverModeMenu();
+	AppendToolMenu();
+	TMainForm_PrevWindowProc = (WNDPROC)::SetWindowLongA(Handle, GWL_WNDPROC, (long)TMainForm_WindowProc);
+#endif
+
+#if defined(FIX_DGRID) && FIX_DGRID
+	TMainForm_PrevDGridProc = (WNDPROC)::SetWindowLongA(DGrid->Handle, GWL_WNDPROC, (long)TMainForm_DGridProc);
+#endif
+
+#if defined(FIX_DGRID) && FIX_DGRID
+	InitializeWaitCursor();
+#endif
+}
+#if (defined(FIX_DGRID) && FIX_DGRID) || (defined(PROCESS_MONITOR) && PROCESS_MONITOR)
+//---------------------------------------------------------------------------
+__fastcall TMainForm::~TMainForm()
+{
+#if defined(OPTIMIZE_GUIDE) && OPTIMIZE_GUIDE
+	ClearGuideBuffer();
+#endif
+	if (TMainForm_PrevDGridProc)
+	{
+		::SetWindowLongA(DGrid->Handle, GWL_WNDPROC, (long)TMainForm_PrevDGridProc);
+		TMainForm_PrevDGridProc = NULL;
+	}
+	if (TMainForm_PrevWindowProc)
+	{
+		::SetWindowLongA(Handle, GWL_WNDPROC, (long)TMainForm_PrevWindowProc);
+		TMainForm_PrevWindowProc = NULL;
+	}
+	DeleteWaitCursor();
+	DeleteProcessMonitor();
 }
+#endif
 //---------------------------------------------------------------------------
 //「終了時に呼ばれる関数」
 //---------------------------------------------------------------------------
@@ -382,7 +879,11 @@
  Map["ShadowOffset"] = "1";
  Map["ShadowColor"] = "0xFFFFFF";
  Map["ShadowMode"] = "0";	//影不要
+#if !defined(FIX_DGRID) || !FIX_DGRID
  Map["TreeFontName"] = "ＭＳ Ｐゴシック";
+#else
+ Map["TreeFontName"] = "ＭＳ ゴシック";
+#endif
  Map["TreeFontSize"] = "12";
  Map["TreeFontStyle"] = "0";
  Map["IsPanelPosRight"] = "1";
@@ -449,6 +950,9 @@
  guideFormWidth = TStringDivision::ToLongDef(Map["GuideFormWidth"].c_str());
  guideFormHeight= TStringDivision::ToLongDef(Map["GuideFormHeight"].c_str());
 
+#if defined(FIX_DGRID) && FIX_DGRID
+ ListLBox->Font->Name = Map["NMemoFontName"].c_str();
+#endif
 
  NoteREdit->Font->Name = Map["NMemoFontName"].c_str();
  NoteREdit->Font->Size = TStringDivision::ToLongDef(Map["NMemoFontSize"].c_str());
@@ -491,6 +995,9 @@
  isAdjustGuideUse    = (Map["IsAdjustGuideUse"] != "0");
 
  userMode = TStringDivision::ToLongDef(Map["UserMode"].c_str());
+#if defined(FIX_USERMODE) && FIX_USERMODE
+ UpdateUserModeMenu();
+#endif
  greatTopModeKey = (byte)TStringDivision::ToLongDef(Map["GreatTopModeKey"].c_str());
 
  if( Map["IsPanelPosRight"] != "0" ){
@@ -528,6 +1035,7 @@
 void __fastcall TMainForm::DGridSelectCell(TObject *Sender, int ACol,
       int ARow, bool &CanSelect)
 {
+#if !defined(FIX_DGRID) || !FIX_DGRID
  if((unsigned long)ARow>treeSubjectVec.size()){
     CanSelect = false;
     return;
@@ -545,6 +1053,102 @@
  selectSubject = treeSubjectVec[ARow-1];
 
  SubjectAccess(selectSubject);
+#else
+	CanSelect = false;
+	if ((unsigned int)ARow <= treeSubjectVec.size())
+		HotKeyEdit->SetFocus();
+#endif
+}
+//---------------------------------------------------------------------------
+#if defined(FIX_DGRID) && FIX_DGRID
+int TMainForm_DGridLButtonDownRow  = -1;
+void __stdcall TMainForm_OnDGridLButtonDown(TMainForm *MainForm, LPARAM lParam)
+{
+	int ACol;
+
+	MainForm->DGrid->MouseToCell(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), ACol, TMainForm_DGridLButtonDownRow);
+}
+//---------------------------------------------------------------------------
+DWORD   TMainForm_DGridLButtonDownTime = 0;
+BOOLEAN TMainForm_DGridLButtonDblClk = FALSE;
+#endif
+void __fastcall TMainForm::DGridMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
+{
+#if defined(FIX_DGRID) && FIX_DGRID
+	if (Button == mbLeft)
+	{
+		DWORD dwMessageTime;
+		DWORD dwElapse;
+
+		dwMessageTime = ::GetMessageTime();
+		dwElapse = dwMessageTime - TMainForm_DGridLButtonDownTime;
+		TMainForm_DGridLButtonDownTime = dwMessageTime;
+		TMainForm_DGridLButtonDblClk = dwElapse <= ::GetDoubleClickTime();
+		if (!TMainForm_DGridLButtonDblClk)
+		{
+			TMainForm_OnDGridLButtonDown(this, MAKELPARAM(X, Y));
+		}
+	}
+#endif
+}
+//---------------------------------------------------------------------------
+#if defined(FIX_DGRID) && FIX_DGRID
+void __stdcall TMainForm_OnDGridLButtonUp(TMainForm *MainForm, LPARAM lParam)
+{
+	int ACol, ARow;
+
+	if (TMainForm_DGridLButtonDblClk)
+		return;
+	if ((unsigned int)TMainForm_DGridLButtonDownRow > MainForm->treeSubjectVec.size())
+		return;
+	MainForm->DGrid->MouseToCell(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), ACol, ARow);
+	if (ARow != TMainForm_DGridLButtonDownRow)
+		return;
+	if (ARow != 0)
+	{
+		int        PrevRow;
+		RECT       PrevRect, Rect;
+		SCROLLINFO si;
+
+		PrevRow = MainForm->nowSelectSubjectIndex + 1;
+		MainForm->nowSelectSubjectIndex = ARow - 1;
+		PrevRect = MainForm->DGrid->CellRect(0, PrevRow);
+		Rect = MainForm->DGrid->CellRect(0, ARow);
+		si.cbSize = sizeof(si);
+		si.fMask = SIF_RANGE | SIF_POS;
+		if (::GetScrollInfo(MainForm->DGrid->Handle, SB_HORZ, &si))
+		{
+			int nRange;
+
+			nRange = si.nMax - si.nMin;
+			if (nRange != 0)
+			{
+				int nXOffset;
+
+				nXOffset = ::MulDiv(MainForm->DGrid->DefaultColWidth - MainForm->DGrid->ClientWidth, si.nPos - si.nMin, nRange);
+				PrevRect.left -= nXOffset;
+				Rect.left -= nXOffset;
+			}
+		}
+		MainForm->DrawTreeCell(MainForm->DGrid->Canvas, PrevRow, PrevRect);
+		MainForm->DrawTreeCell(MainForm->DGrid->Canvas, ARow, Rect);
+		MainForm->SubjectAccess(MainForm->selectSubject = MainForm->treeSubjectVec[MainForm->nowSelectSubjectIndex]);
+	}
+	else
+	{
+		MainForm->M_TitleSelectClick(MainForm->M_TitleSelect);
+	}
+}
+//---------------------------------------------------------------------------
+#endif
+void __fastcall TMainForm::DGridMouseUp(TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y)
+{
+#if defined(FIX_DGRID) && FIX_DGRID
+	if (Button == mbLeft)
+	{
+		TMainForm_OnDGridLButtonUp(this, MAKELPARAM(X, Y));
+	}
+#endif
 }
 //---------------------------------------------------------------------------
 //「項目へのアクセス関数」
@@ -554,6 +1158,9 @@
  canChange = false;
 
 
+#if defined(FIX_SUBJECT_ACCESS) && FIX_SUBJECT_ACCESS
+ if (SelectS->GetArgType() != ssgCtrl::atDIR || !((TSSDir *)SelectS)->IsSameChildren() || ssgCtrl.IsChildRWProhibit(SelectS))
+#endif
  ChangeSubjectPanel(SelectS->GetArgType());
  {//Caution属性のチェック
     vector<string> *tmpV = ssgCtrl.GetCautionVec(SelectS);
@@ -617,8 +1224,20 @@
  case ssgCtrl::atLONG_INDEX:{
     TSSArgLongIndexSubject *SSGS = (TSSArgLongIndexSubject *)SelectS;
 
+#if !defined(COMMON_LIST) || !COMMON_LIST
     vector<string> *ListFile
         = ssgCtrl.GetSSGDataFile(SSGS, SSGS->GetIndexFileName(), ".LST");
+#else
+	vector<string> *ListFile;
+	char FileNamePrefix;
+	{
+		string FileName(SSGS->GetIndexFileName());
+		FileNamePrefix = *FileName.c_str();
+		if (FileNamePrefix == '+')
+			FileName.erase(0, 1);
+		ListFile = ssgCtrl.GetSSGDataFile(SSGS, FileName, ".LST");
+	}
+#endif
     if(ListFile==NULL){
         ShowMessage("リストファイルが読み込めません！SSGにミスはありませんか？\n指定されたファイルは存在していますか？");
         break;
@@ -634,7 +1253,18 @@
 		VEnd = ListFile->end();
     for(; VIt!=VEnd; VIt++){
         if(StrSize<VIt->size()) StrSize = VIt->size();
+#if !defined(COMMON_LIST) || !COMMON_LIST
         ListLBox->Items->Add(VIt->c_str());
+#else
+		LPCSTR Text = VIt->c_str();
+		if (FileNamePrefix == '+')
+		{
+			while (*Text && *(Text++) != '=');
+			while (__intrinsic_isspace(*Text))
+				Text++;
+		}
+		ListLBox->Items->Add(Text);
+#endif
     }
     ListLBox->Items->EndUpdate();
     SendMessage(ListLBox->Handle, LB_SETHORIZONTALEXTENT,
@@ -761,7 +1391,16 @@
  {//違反チェック
  }
  {//書き込み
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+	ClearErrorMessageId();
+#endif
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	switch( selectSubject->Write(ssgCtrl, &Val) ){
+#else
+	unsigned long status = selectSubject->Write(ssgCtrl, &Val);
+	DrawTree(NULL, 0, 0, TRUE);
+	switch (status) {
+#endif
 	case ssgCtrl::reNO_ERROR: //成功
 		if(LockCBox->Visible && LockCBox->Checked) //ロック値も変更
             ssgCtrl.SetLock(true, selectSubject, Val.Clone());
@@ -771,7 +1410,11 @@
         ShowMessage("SSG Error. No On-Code!");
 		return;
 	default:
+#if !defined(SHOW_ERROR_MESSAGE) || !SHOW_ERROR_MESSAGE
         ShowMessage("Not Defined Error!");
+#else
+		ShowErrorMessage();
+#endif
         return;
 	}
  }
@@ -794,7 +1437,16 @@
  }
  {//書き込み
 
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+	ClearErrorMessageId();
+#endif
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	switch( selectSubject->Write(ssgCtrl, &Val) ){
+#else
+	unsigned long status = selectSubject->Write(ssgCtrl, &Val);
+	DrawTree(NULL, 0, 0, TRUE);
+	switch (status) {
+#endif
 	case ssgCtrl::reNO_ERROR:{ //成功
 		if(LockCBox->Visible && LockCBox->Checked) //ロック値も変更
             ssgCtrl.SetLock(true, selectSubject, Val.Clone());
@@ -806,7 +1458,11 @@
         ShowMessage("SSG Error. No List-File!");
         return;
 	default:
+#if !defined(SHOW_ERROR_MESSAGE) || !SHOW_ERROR_MESSAGE
         ShowMessage("Not Defined Error!");
+#else
+		ShowErrorMessage();
+#endif
         return;
 	}
  }
@@ -850,7 +1506,16 @@
  }
  {//書き込み
 	//チェックに変化があったので、書き換え開始
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+	ClearErrorMessageId();
+#endif
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	switch( selectSubject->Write(ssgCtrl, &Val) ){
+#else
+	unsigned long status = selectSubject->Write(ssgCtrl, &Val);
+	DrawTree(NULL, 0, 0, TRUE);
+	switch (status) {
+#endif
 	case ssgCtrl::reNO_ERROR:{ //成功
 		if(LockCBox->Visible && LockCBox->Checked) //ロック値も変更
             ssgCtrl.SetLock(true, selectSubject, Val.Clone());
@@ -860,7 +1525,11 @@
         ShowMessage("SSG Error. No List/Chain-File!");
         return;
 	default:
+#if !defined(SHOW_ERROR_MESSAGE) || !SHOW_ERROR_MESSAGE
         ShowMessage("Not Defined Error!");
+#else
+		ShowErrorMessage();
+#endif
         return;
 	}
  }
@@ -887,13 +1556,26 @@
  }
 
  {//書き込み
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+	ClearErrorMessageId();
+#endif
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	switch( selectSubject->Write(ssgCtrl, &Val) ){
+#else
+	unsigned long status = selectSubject->Write(ssgCtrl, &Val);
+	DrawTree(NULL, 0, 0, TRUE);
+	switch (status) {
+#endif
 	case ssgCtrl::reNO_ERROR:{ //成功
 		if(LockCBox->Visible && LockCBox->Checked) //ロック値も変更
             ssgCtrl.SetLock(true, selectSubject, Val.Clone());
 		break;}
 	default:
+#if !defined(SHOW_ERROR_MESSAGE) || !SHOW_ERROR_MESSAGE
         ShowMessage("Not Defined Error!");
+#else
+		ShowErrorMessage();
+#endif
         return;
 	}
  }
@@ -959,7 +1641,16 @@
  }
  
  {//書き込み
+#if defined(SHOW_ERROR_MESSAGE) && SHOW_ERROR_MESSAGE
+	ClearErrorMessageId();
+#endif
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	switch( selectSubject->Write(ssgCtrl, Val) ){
+#else
+	unsigned long status = selectSubject->Write(ssgCtrl, Val);
+	DrawTree(NULL, 0, 0, TRUE);
+	switch (status) {
+#endif
 	case ssgCtrl::reNO_ERROR:{ //成功
 	    SetCalcNowValue( Val );
 
@@ -967,7 +1658,11 @@
             ssgCtrl.SetLock(true, selectSubject, Val->Clone());
 		break;}
 	default:
+#if !defined(SHOW_ERROR_MESSAGE) || !SHOW_ERROR_MESSAGE
         ShowMessage("Not Defined Error!");
+#else
+		ShowErrorMessage();
+#endif
 		delete Val;
         return;
     }
@@ -1188,6 +1883,7 @@
  }else{
     switch(Key){
     case VK_UP:
+#if !defined(FIX_DGRID) || !FIX_DGRID
         if(invertGridRow<0){
            invertGridRow = 0;
            DGrid->TopRow = 0;
@@ -1198,7 +1894,82 @@
             DGrid->Repaint();
         }
         break;
+#else
+        {
+            int topRow;
+
+            topRow = DGrid->TopRow >= 0 ? DGrid->TopRow : 0;
+            if (invertGridRow)
+            {
+                HWND       DGridHandle;
+                RECT       rect;
+                int        clientWidth, clientHeight;
+                SCROLLINFO si;
+
+                DGridHandle = DGrid->Handle;
+                ::GetClientRect(DGridHandle, &rect);
+                clientWidth = rect.right - rect.left;
+                clientHeight = rect.bottom - rect.top;
+                rect.left = 0;
+                si.cbSize = sizeof(SCROLLINFO);
+                si.fMask = SIF_RANGE | SIF_POS;
+                if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+                {
+                    int pos;
+
+                    pos = si.nPos - si.nMin;
+                    if (pos)
+                    {
+                        int range;
+
+                        range = si.nMax - si.nMin;
+                        if (range)
+                        {
+                            rect.left = -::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+                        }
+                    }
+                }
+                rect.right = rect.left + DGrid->DefaultColWidth;
+                if (invertGridRow >= 0)
+                {
+                    int bottomRow;
+
+                    rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+                    rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                    DrawTreeCell(DGrid->Canvas, invertGridRow--, rect);
+                    bottomRow = clientHeight / DGrid->DefaultRowHeight + topRow - 2;
+                    if (invertGridRow <= bottomRow)
+                    {
+                        rect.bottom = rect.top;
+                        rect.top -= DGrid->DefaultRowHeight;
+                    }
+                    else
+                    {
+                        invertGridRow = bottomRow;
+                        rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+                        rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                    }
+                }
+                else
+                {
+                    invertGridRow = 0;
+                    rect.top = -topRow * DGrid->DefaultRowHeight;
+                    rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                }
+                DrawTreeCell(DGrid->Canvas, invertGridRow, rect);
+            }
+            if (topRow)
+            {
+                topRow--;
+                if (invertGridRow < topRow)
+                    invertGridRow = topRow;
+                DGrid->TopRow = topRow;
+            }
+        }
+        return;
+#endif
     case VK_DOWN:
+#if !defined(FIX_DGRID) || !FIX_DGRID
         if(invertGridRow<0){
             invertGridRow = DGrid->RowCount-DGrid->Height/DGrid->DefaultRowHeight;
             if(invertGridRow<0) invertGridRow=0;
@@ -1211,6 +1982,320 @@
             DGrid->Repaint();
         }
         break;
+#else
+        {
+            HWND       DGridHandle;
+            RECT       rect;
+            int        clientWidth, clientHeight;
+            SCROLLINFO si;
+            int        topRow;
+            int        clientRows;
+
+            DGridHandle = DGrid->Handle;
+            ::GetClientRect(DGridHandle, &rect);
+            clientWidth = rect.right - rect.left;
+            clientHeight = rect.bottom - rect.top;
+            rect.left = 0;
+            si.cbSize = sizeof(SCROLLINFO);
+            si.fMask = SIF_RANGE | SIF_POS;
+            if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+            {
+                int pos;
+
+                pos = si.nPos - si.nMin;
+                if (pos)
+                {
+                    int range;
+
+                    range = si.nMax - si.nMin;
+                    if (range)
+                    {
+                        rect.left = -::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+                    }
+                }
+            }
+            rect.right = rect.left + DGrid->DefaultColWidth;
+            if (invertGridRow < 0)
+                invertGridRow = 0;
+            topRow = DGrid->TopRow >= 0 ? DGrid->TopRow : 0;
+            do	/* do { ... } while (0); */
+            {
+                if (invertGridRow < topRow)
+                {
+                    invertGridRow = topRow + 1;
+                    rect.top = DGrid->DefaultRowHeight;
+                    rect.bottom = DGrid->DefaultRowHeight * 2;
+                }
+                else
+                {
+                    if (invertGridRow >= DGrid->RowCount - 2)
+                        break;
+                    rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+                    rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                    DrawTreeCell(DGrid->Canvas, invertGridRow++, rect);
+                    rect.top = rect.bottom;
+                    rect.bottom += DGrid->DefaultRowHeight;
+                }
+                DrawTreeCell(DGrid->Canvas, invertGridRow, rect);
+            } while (0);
+            clientRows = clientHeight / DGrid->DefaultRowHeight;
+            if (topRow < DGrid->RowCount - clientRows)
+            {
+                int bottomRow;
+
+                bottomRow = topRow + clientRows;
+                if (invertGridRow > bottomRow)
+                {
+                    invertGridRow = bottomRow;
+                    rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+                    rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                    DrawTreeCell(DGrid->Canvas, invertGridRow, rect);
+                }
+                DGrid->TopRow = topRow + 1;
+            }
+        }
+        return;
+    case VK_PRIOR:
+        {
+            HWND       DGridHandle;
+            RECT       rect;
+            int        clientWidth, clientHeight;
+            SCROLLINFO si;
+            int        topRow;
+            int        row;
+            int        clientRows;
+            int        bottomRow;
+
+            DGridHandle = DGrid->Handle;
+            ::GetClientRect(DGridHandle, &rect);
+            clientWidth = rect.right - rect.left;
+            clientHeight = rect.bottom - rect.top;
+            rect.left = 0;
+            si.cbSize = sizeof(SCROLLINFO);
+            si.fMask = SIF_RANGE | SIF_POS;
+            if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+            {
+                int pos;
+
+                pos = si.nPos - si.nMin;
+                if (pos)
+                {
+                    int range;
+
+                    range = si.nMax - si.nMin;
+                    if (range)
+                    {
+                        rect.left = -::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+                    }
+                }
+            }
+            rect.right = rect.left + DGrid->DefaultColWidth;
+            if (invertGridRow < 0)
+                invertGridRow = 0;
+            topRow = DGrid->TopRow >= 0 ? DGrid->TopRow : 0;
+            rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+            rect.bottom = rect.top + DGrid->DefaultRowHeight;
+            row = invertGridRow;
+            clientRows = clientHeight / DGrid->DefaultRowHeight;
+            invertGridRow = invertGridRow > clientRows ? invertGridRow - clientRows : 0;
+            DrawTreeCell(DGrid->Canvas, row, rect);
+            bottomRow = topRow - 1;
+            if (bottomRow < clientRows)
+                bottomRow = clientRows;
+            if (invertGridRow > bottomRow)
+                invertGridRow = bottomRow;
+            rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+            rect.bottom = rect.top + DGrid->DefaultRowHeight;
+            DrawTreeCell(DGrid->Canvas, invertGridRow, rect);
+            if (topRow)
+            {
+                topRow = topRow > clientRows ? topRow - clientRows : 0;
+                if (invertGridRow < topRow)
+                    invertGridRow = topRow;
+                DGrid->TopRow = topRow;
+            }
+        }
+        return;
+    case VK_NEXT:
+        {
+            HWND       DGridHandle;
+            RECT       rect;
+            int        clientWidth, clientHeight;
+            SCROLLINFO si;
+            int        topRow;
+            int        clientRows;
+            int        bottomRow;
+
+            DGridHandle = DGrid->Handle;
+            ::GetClientRect(DGridHandle, &rect);
+            clientWidth = rect.right - rect.left;
+            clientHeight = rect.bottom - rect.top;
+            rect.left = 0;
+            si.cbSize = sizeof(SCROLLINFO);
+            si.fMask = SIF_RANGE | SIF_POS;
+            if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+            {
+                int pos;
+
+                pos = si.nPos - si.nMin;
+                if (pos)
+                {
+                    int range;
+
+                    range = si.nMax - si.nMin;
+                    if (range)
+                    {
+                        rect.left = -::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+                    }
+                }
+            }
+            rect.right = rect.left + DGrid->DefaultColWidth;
+            if (invertGridRow < 0)
+                invertGridRow = 0;
+            topRow = DGrid->TopRow >= 0 ? DGrid->TopRow : 0;
+            clientRows = clientHeight / DGrid->DefaultRowHeight;
+            bottomRow = topRow + clientRows;
+            if (invertGridRow < topRow)
+            {
+                invertGridRow = bottomRow;
+                rect.top = clientRows * DGrid->DefaultRowHeight;
+            }
+            else
+            {
+                int row;
+
+                rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+                rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                row = invertGridRow;
+                if (invertGridRow < bottomRow)
+                {
+                    int maxRow;
+
+                    invertGridRow += clientRows;
+                    maxRow = DGrid->RowCount - 2;
+                    if (invertGridRow > maxRow)
+                        invertGridRow = maxRow;
+                }
+                else
+                {
+                    invertGridRow = bottomRow + clientRows - 1;
+                }
+                DrawTreeCell(DGrid->Canvas, row, rect);
+                rect.top = (invertGridRow - topRow) * DGrid->DefaultRowHeight;
+            }
+            rect.bottom = rect.top + DGrid->DefaultRowHeight;
+            DrawTreeCell(DGrid->Canvas, invertGridRow, rect);
+            if (topRow < (DGrid->RowCount > clientRows ? DGrid->RowCount - clientRows : 0))
+            {
+                int maxTopRow;
+
+                topRow = bottomRow;
+                maxTopRow = DGrid->RowCount - clientRows;
+                if (topRow > maxTopRow)
+                    topRow = maxTopRow;
+                DGrid->TopRow = topRow;
+            }
+        }
+        return;
+    case VK_HOME:
+        {
+            HWND       DGridHandle;
+            RECT       rect;
+            int        clientWidth;
+            SCROLLINFO si;
+            int        row;
+            int        topRow;
+
+            DGridHandle = DGrid->Handle;
+            ::GetClientRect(DGridHandle, &rect);
+            clientWidth = rect.right - rect.left;
+            rect.left = 0;
+            si.cbSize = sizeof(SCROLLINFO);
+            si.fMask = SIF_RANGE | SIF_POS;
+            if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+            {
+                int pos;
+
+                pos = si.nPos - si.nMin;
+                if (pos)
+                {
+                    int range;
+
+                    range = si.nMax - si.nMin;
+                    if (range)
+                    {
+                        rect.left = -::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+                    }
+                }
+            }
+            rect.right = rect.left + DGrid->DefaultColWidth;
+            row = invertGridRow >= 0 ? invertGridRow : 0;
+            invertGridRow = 0;
+            topRow = DGrid->TopRow >= 0 ? DGrid->TopRow : 0;
+            rect.top = (row - topRow) * DGrid->DefaultRowHeight;
+            rect.bottom = rect.top + DGrid->DefaultRowHeight;
+            DrawTreeCell(DGrid->Canvas, row, rect);
+            rect.top = -topRow * DGrid->DefaultRowHeight;
+            rect.bottom = rect.top + DGrid->DefaultRowHeight;
+            DrawTreeCell(DGrid->Canvas, 0, rect);
+            DGrid->TopRow = 0;
+        }
+        return;
+    case VK_END:
+        {
+            HWND DGridHandle;
+            RECT rect;
+            int  clientWidth, clientHeight;
+            int  topRow;
+            int  maxRow;
+            int  clientRows;
+
+            DGridHandle = DGrid->Handle;
+            ::GetClientRect(DGridHandle, &rect);
+            clientWidth = rect.right - rect.left;
+            clientHeight = rect.bottom - rect.top;
+            topRow = DGrid->TopRow >= 0 ? DGrid->TopRow : 0;
+            maxRow = DGrid->RowCount > 2 ? DGrid->RowCount - 2 : 0;
+            if (invertGridRow != maxRow)
+            {
+                RECT       rect;
+                SCROLLINFO si;
+                int        row;
+
+                rect.left = 0;
+                si.cbSize = sizeof(SCROLLINFO);
+                si.fMask = SIF_RANGE | SIF_POS;
+                if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+                {
+                    int pos;
+
+                    pos = si.nPos - si.nMin;
+                    if (pos)
+                    {
+                        int range;
+
+                        range = si.nMax - si.nMin;
+                        if (range)
+                        {
+                            rect.left = -::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+                        }
+                    }
+                }
+                rect.right = rect.left + DGrid->DefaultColWidth;
+                row = invertGridRow >= 0 ? invertGridRow : 0;
+                invertGridRow = maxRow;
+                rect.top = (row - topRow) * DGrid->DefaultRowHeight;
+                rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                DrawTreeCell(DGrid->Canvas, row, rect);
+                rect.top = (maxRow - topRow) * DGrid->DefaultRowHeight;
+                rect.bottom = rect.top + DGrid->DefaultRowHeight;
+                DrawTreeCell(DGrid->Canvas, maxRow, rect);
+            }
+            clientRows = clientHeight / DGrid->DefaultRowHeight;
+            DGrid->TopRow = DGrid->RowCount > clientRows ? DGrid->RowCount - clientRows : 0;
+        }
+        return;
+#endif
     case VK_RIGHT:{
         bool tmpB;
         DGridSelectCell(DGrid, 0, invertGridRow, tmpB);
@@ -1355,6 +2440,98 @@
 //---------------------------------------------------------------------------
 //「項目ツリーグリッドの描画イベント」
 //---------------------------------------------------------------------------
+#if defined(FIX_DGRID) && FIX_DGRID
+void __stdcall TMainForm_DrawTreeCell_DrawHover(int ARow, int invertGridRow, Graphics::TBitmap *invertImage, long RectW, long RectH, TCanvas *BSCanvas)
+{
+	if ((ARow == invertGridRow) && (invertImage != NULL))
+	{
+		HDC           BSCanvasHandle, invertImageHandle;
+		BLENDFUNCTION blendFunction;
+
+		invertImage->Width = RectW;
+		invertImage->Height = RectH;
+		BSCanvasHandle = BSCanvas->Handle;
+		invertImageHandle = invertImage->Canvas->Handle;
+		::BitBlt(invertImageHandle, 0, 0, RectW, RectH, BSCanvasHandle, 0, 0, NOTSRCCOPY);
+		blendFunction.BlendOp             = AC_SRC_OVER;
+		blendFunction.BlendFlags          = 0;
+		blendFunction.SourceConstantAlpha = 48;
+		blendFunction.AlphaFormat         = 0;
+		::AlphaBlend(BSCanvasHandle, 0, 0, RectW, RectH, invertImageHandle, 0, 0, RectW, RectH, blendFunction);
+	}
+}
+//---------------------------------------------------------------------------
+void __stdcall TMainForm_DrawTreeCell_FixDefaultColWidth(TSSGSubject *SSGS, TCanvas *Canvas, int X, int Y, const string &Text)
+{
+	SIZE                size;
+	TSSGSubjectProperty *elem;
+	TMainForm           *_this;
+
+	::GetTextExtentPoint32A(Canvas->Handle, Text.c_str(), Text.length(), &size);
+	size.cx += X + 6;
+	elem = GetSubjectProperty(SSGS);
+	if (elem != NULL)
+		elem->Width = size.cx;
+	_this = MainForm;
+	if (_this->DGrid->DefaultColWidth < size.cx)
+	{
+		HWND         DGridHandle;
+		long         lStyle;
+		unsigned int ClientHeight;
+		unsigned int SubjectCount;
+		unsigned int SubjectHeight;
+		unsigned int FillHeight;
+		int          wBar;
+
+		DGridHandle = _this->DGrid->Handle;
+		lStyle = ::GetWindowLongA(DGridHandle, GWL_STYLE);
+		_this->DGrid->DefaultColWidth = size.cx;
+		ClientHeight = _this->DGrid->ClientHeight;
+		SubjectCount = _this->DGrid->RowCount - 1;
+		SubjectHeight = _this->DGrid->DefaultRowHeight * SubjectCount;
+		if (ClientHeight >= SubjectHeight)
+		{
+			FillHeight = ClientHeight - SubjectHeight;
+			wBar = SB_HORZ;
+		}
+		else
+		{
+			FillHeight = _this->DGrid->DefaultRowHeight + ClientHeight % _this->DGrid->DefaultRowHeight;
+			wBar = SB_BOTH;
+		}
+		_this->DGrid->RowHeights[SubjectCount] = FillHeight;
+		::ShowScrollBar(DGridHandle, wBar, TRUE);
+		if (!(lStyle & WS_HSCROLL))
+		{
+			SCROLLINFO si;
+
+			si.cbSize = sizeof(SCROLLINFO);
+			si.fMask = SIF_RANGE;
+			si.nMin = 0;
+			si.nMax = _this->DGrid->DefaultColWidth - _this->DGrid->ClientWidth;
+			::SetScrollInfo(DGridHandle, SB_HORZ, &si, FALSE);
+		}
+	}
+	Canvas->TextOut(X, Y, Text.c_str());
+}
+//---------------------------------------------------------------------------
+void __stdcall TMainForm_DrawTreeCell_DrawFocusRect(int ARow, int nowSelectSubjectIndex, TMainForm *MainForm, TCanvas *BSCanvas)
+{
+	if (ARow == nowSelectSubjectIndex + 1)
+	{
+		TDrawGrid *DGrid;
+		RECT      rcItem;
+
+		DGrid = MainForm->DGrid;
+		rcItem.left = 2;
+		rcItem.top = 2;
+		rcItem.right = DGrid->DefaultColWidth - 2;
+		rcItem.bottom = DGrid->DefaultRowHeight - 2;
+		::DrawFocusRect(BSCanvas->Handle, &rcItem);
+	}
+}
+//---------------------------------------------------------------------------
+#endif
 void TMainForm::DrawTreeCell(TCanvas *DestCanvas, int ARow, TRect &Rect)
 {
  if(treeBackScreen==NULL) return;
@@ -1411,6 +2588,10 @@
     return;
  }
 
+#if defined(FIX_DGRID) && FIX_DGRID
+ TMainForm_DrawTreeCell_DrawHover(ARow, invertGridRow, invertImage, RectW, RectH, BSCanvas);
+#endif
+
  TSSGSubject *SSGS = NULL;
  long DrawX, DrawY;
  string DrawStr;
@@ -1431,6 +2612,9 @@
     
 	if(SSGS->GetType()==ssgCtrl::stSPLIT){
 		TSSSplit *SS = (TSSSplit *)SSGS;
+#if defined(FIX_DGRID) && FIX_DGRID
+		if (SS->GetDrawType() != 3)
+#endif
 		switch(SS->GetIndentType()){
 		case 0:	//offset
 			DrawX += treeFontWidth*SS->GetIndent();
@@ -1481,7 +2665,11 @@
 	    	        	DrawStr += "["+ ListFile->at(Val) +"]";
             	    break;}
 	            case ssgCtrl::atDOUBLE:{
+#if !defined(FIX_DGRID) || !FIX_DGRID
     	            DrawStr += TStringDivision::ToString(((TSSArgDouble*)Arg)->GetValue(), "[%f]" );
+#else
+					DrawStr += TStringDivision::ToStringDouble(((TSSArgDouble*)Arg)->GetValue(), "[%f]");
+#endif
         	        break;}
             	case ssgCtrl::atBOOL:{
                 	DrawStr += ((TSSArgBool*)Arg)->GetValue() ? "[on]" : "[off]";
@@ -1497,7 +2685,6 @@
 	        }
 		}
     }
-
  }
 
  if(!DrawStr.empty()){
@@ -1510,11 +2697,19 @@
 	case 1:{    //影落とし(固定色)
 	    long Offset = shadowOffset;
     	BSCanvas->Font->Color = (TColor)shadowColor;
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	    BSCanvas->TextOut(DrawX+Offset, DrawY+Offset, DrawStr.c_str());
+#else
+		TMainForm_DrawTreeCell_FixDefaultColWidth(SSGS, BSCanvas, DrawX + Offset, DrawY + Offset, DrawStr);
+#endif
     	}//そのまま次の処理へ
 	case 0:{   //加工無し
 	    BSCanvas->Font->Color = DrawColor;
+#if !defined(FIX_DGRID) || !FIX_DGRID
     	BSCanvas->TextOut(DrawX       , DrawY       , DrawStr.c_str());
+#else
+		TMainForm_DrawTreeCell_FixDefaultColWidth(SSGS, BSCanvas, DrawX, DrawY, DrawStr);
+#endif
 	    break;}
 	case 4:{    //影囲い(反転色)
 	    long Offset = shadowOffset;
@@ -1524,7 +2719,11 @@
 	case 2:{    //影落とし(反転色)
 	    long Offset = shadowOffset;
     	BSCanvas->Font->Color = (TColor)((~DrawColor)&0xFFFFFF);
+#if !defined(FIX_DGRID) || !FIX_DGRID
 	    BSCanvas->TextOut(DrawX+Offset, DrawY+Offset, DrawStr.c_str());
+#else
+		TMainForm_DrawTreeCell_FixDefaultColWidth(SSGS, BSCanvas, DrawX + Offset, DrawY + Offset, DrawStr);
+#endif
     	BSCanvas->Font->Color = DrawColor;
 	    BSCanvas->TextOut(DrawX       , DrawY       , DrawStr.c_str());
     	break;}
@@ -1553,6 +2752,7 @@
 	BSCanvas->Pen->Mode = pmCopy;
  }
 
+#if !defined(FIX_DGRID) || !FIX_DGRID
  //「選択状態の項目部分を反転させる処理」
  if((ARow==invertGridRow)&&(invertImage!=NULL)){
     invertImage->Width  = RectW;
@@ -1560,7 +2760,11 @@
     BitBlt(BSCanvas->Handle, 0, 0, RectW, RectH,
         invertImage->Canvas->Handle, 0, 0, cmDstInvert );
  }
+#endif
 
+#if defined(FIX_DGRID) && FIX_DGRID
+ TMainForm_DrawTreeCell_DrawFocusRect(ARow, nowSelectSubjectIndex, this, BSCanvas);
+#endif
 
  //転送
  BitBlt(DestCanvas->Handle, Rect.Left, Rect.Top,
@@ -1569,6 +2773,7 @@
 //---------------------------------------------------------------------------
 //「項目ツリーの描画催促関数」
 //---------------------------------------------------------------------------
+#if !defined(FIX_DGRID) || !FIX_DGRID
 void TMainForm::DrawTree(TCanvas *DestCanvas, long LeftOffset, long TopOffset)
 {
  /*
@@ -1598,6 +2803,78 @@
     }
  }
 }
+#else
+void TMainForm::DrawTree(TCanvas *DestCanvas, long LeftOffset, long TopOffset, BOOL IgnoreDebugString)
+{
+	HWND                  DGridHandle;
+	RECT                  rect;
+	int                   clientWidth, clientHeight, clientRows;
+	SCROLLINFO            si;
+	int                   span;
+	int                   i, end;
+	TSSGActionListnerBase *ssgActionListner;
+
+	DGridHandle = DGrid->Handle;
+	::GetClientRect(DGridHandle, &rect);
+	clientWidth = rect.right - rect.left;
+	clientHeight = rect.bottom - rect.top;
+	si.cbSize = sizeof(SCROLLINFO);
+	si.fMask = SIF_RANGE | SIF_POS;
+	if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+	{
+		int pos;
+
+		pos = si.nPos - si.nMin;
+		if (pos)
+		{
+			int range;
+
+			range = si.nMax - si.nMin;
+			if (range)
+			{
+				LeftOffset -= ::MulDiv(DGrid->DefaultColWidth - clientWidth, pos, range);
+			}
+		}
+	}
+
+	span = DGrid->DefaultRowHeight;
+	rect.left = LeftOffset;
+	rect.right = DGrid->DefaultColWidth + LeftOffset;
+	if (DestCanvas)
+	{
+		rect.top = TopOffset;
+	}
+	else
+	{
+		rect.top = 0;
+		DestCanvas = DGrid->Canvas;
+	}
+	rect.bottom = rect.top + span;
+
+	i = DGrid->TopRow;
+	end = clientHeight / DGrid->DefaultRowHeight;
+	if (clientHeight % DGrid->DefaultRowHeight)
+		end++;
+	end += i;
+	if (end > DGrid->RowCount)
+		end = DGrid->RowCount;
+	if (IgnoreDebugString)
+	{
+		ssgActionListner = ssgCtrl.GetSSGActionListner();
+		ssgCtrl.SetSSGActionListner(NULL);
+	}
+	for (end--; i < end; i++)
+	{
+		DrawTreeCell(DestCanvas, i, rect);
+		rect.top += span;
+		rect.bottom += span;
+	}
+	rect.bottom = rect.top + DGrid->RowHeights[end];
+	DrawTreeCell(DestCanvas, end, rect);
+	if (IgnoreDebugString)
+		ssgCtrl.SetSSGActionListner(ssgActionListner);
+}
+#endif
 //---------------------------------------------------------------------------
 //「描画色の選定関数」
 //---------------------------------------------------------------------------
@@ -1648,6 +2925,9 @@
     StringNewValEdit->Visible = false;
     ListLBox->Visible   = false;
     MultiLBox->Visible  = false;
+#if defined(FIX_CHANGE_SUBJECT_PANEL) && FIX_CHANGE_SUBJECT_PANEL
+    StringEnterBtn->Visible = false;
+#endif
     calcImage->SetEditVisible(false);
     PageCtrl->ActivePage = CtrlTabS;
     break;
@@ -1767,7 +3047,11 @@
     return;
 
  invertGridRow = ARow;
+#if !defined(FIX_USERMODE) || !FIX_USERMODE
  DGrid->Repaint();
+#else
+ DrawTree(NULL, 0, 0, userMode == 4);
+#endif
 
 }
  //---------------------------------------------------------------------------
@@ -1806,7 +3090,12 @@
  }
 
  //「項目表示ツリーの親に、サイズ変更が起こったときのイベント」
+#if !defined(FIX_MOUSE_WHEEL) || !FIX_MOUSE_WHEEL
  CheckTreeSize();
+#else
+ DGrid->Width = Splitter->Left;
+ CheckTreeSize(true);
+#endif
 
 }
 //---------------------------------------------------------------------------
@@ -1815,6 +3104,7 @@
 void __fastcall TMainForm::FormMouseWheel(TObject *Sender,
       TShiftState Shift, int WheelDelta, TPoint &MousePos, bool &Handled)
 {
+#if !defined(FIX_MOUSE_WHEEL) || !FIX_MOUSE_WHEEL
  Handled = false;
  
  wheelDeltaCount += WheelDelta;
@@ -1831,12 +3121,83 @@
  }
  DGrid->TopRow = Row;
 
+#else
+	HWND DGridHandle;
+	RECT rect;
+
+	DGridHandle = DGrid->Handle;
+	if (::GetWindowRect(DGridHandle, &rect) && ::PtInRect(&rect, MousePos))
+	{
+		long lStyle;
+
+		Handled = true;
+		lStyle = ::GetWindowLongA(DGridHandle, GWL_STYLE);
+		if (lStyle & WS_VSCROLL)
+		{
+			int topRow;
+
+			topRow = DGrid->TopRow - WheelDelta / 120;
+			if (topRow > 0)
+			{
+				int clientRows;
+
+				clientRows = DGrid->ClientHeight / DGrid->DefaultRowHeight;
+				if (DGrid->RowCount > clientRows)
+				{
+					int maxTopRow;
+
+					maxTopRow = DGrid->RowCount - clientRows;
+					if (topRow > maxTopRow)
+					{
+						topRow = maxTopRow;
+					}
+				}
+				else
+				{
+					topRow = 0;
+				}
+			}
+			else
+			{
+				topRow = 0;
+			}
+			DGrid->TopRow = topRow;
+		}
+		else if (lStyle & WS_HSCROLL)
+		{
+			SCROLLINFO si;
+
+			si.cbSize = sizeof(SCROLLINFO);
+			si.fMask = SIF_RANGE | SIF_POS;
+			if (::GetScrollInfo(DGridHandle, SB_HORZ, &si))
+			{
+				int clientWidth;
+
+				clientWidth = DGrid->ClientWidth;
+				if (clientWidth)
+				{
+					si.nPos -= ::MulDiv(::MulDiv(::GetSystemMetrics(SM_CXHTHUMB), WheelDelta, 120), si.nMax - si.nMin, clientWidth);
+					if (si.nPos < si.nMin)
+						si.nPos = si.nMin;
+					else if (si.nPos > si.nMax)
+						si.nPos = si.nMax;
+					::SendMessage(DGridHandle, WM_HSCROLL, MAKEWPARAM(SB_THUMBTRACK, si.nPos), (LPARAM)NULL);
+				}
+			}
+		}
+	}
+	else if (!::GetWindowRect(PageCtrl->Handle, &rect) || !::PtInRect(&rect, MousePos))
+	{
+		Handled = true;
+	}
+#endif
 }
 //---------------------------------------------------------------------------
 //「項目ツリーの表示に必要なサイズを調べる関数」
 //---------------------------------------------------------------------------
 void TMainForm::CheckTreeSize(bool AllWidthCheck)
 {
+#if !defined(FIX_DGRID) || !FIX_DGRID
 
  if(AllWidthCheck){//横方向のサイズ調整
     if(treeSubjectVec.size()+2 != (unsigned long)DGrid->RowCount){
@@ -1881,6 +3242,119 @@
  }
 
  DrawTree();
+#else
+	static BOOL   InProcessing = FALSE;
+	HWND          DGridHandle;
+	SIZE          TextSize;
+	unsigned long RowHeight;
+	unsigned long SubjectCount;
+	unsigned long SubjectWidth;
+	unsigned long SubjectHeight;
+	unsigned long cx;
+	unsigned long cy;
+	unsigned int  uShow, uHide;
+	unsigned int  FillHeight;
+
+	// cancel recursive call
+	if (InProcessing)
+		return;
+	InProcessing = TRUE;
+
+	// set wait cursor
+	BeginWaitCursor();
+
+	// suspend redraw
+	DGridHandle = DGrid->Handle;
+	::SendMessageA(DGridHandle, WM_SETREDRAW, FALSE, 0);
+
+	// 文字サイズ基準の調整
+	::GetTextExtentPoint32A(treeBackScreen->Canvas->Handle, "╋", 2, &TextSize);
+	treeFontWidth = TextSize.cx;
+	RowHeight = TextSize.cy + 8;
+	DGrid->DefaultRowHeight = RowHeight;
+
+	// 横方向のサイズ調整
+	SubjectCount = treeSubjectVec.size() + 1;
+	if (SubjectCount + 1 != (unsigned long)DGrid->RowCount)
+		DGrid->RowCount = SubjectCount + 1;
+
+	// calculate max width from all rows
+	SubjectWidth = 0;
+	for (vector<TSSGSubject *>::iterator it = treeSubjectVec.begin(); it != treeSubjectVec.end(); it++)
+	{
+		TSSGSubjectProperty *elem;
+
+		elem = GetSubjectProperty(*it);
+		if (elem == NULL)
+			continue;
+		if (SubjectWidth < elem->Width)
+			SubjectWidth = elem->Width;
+	}
+
+	// calculate height of all rows
+	SubjectHeight = SubjectCount * RowHeight;
+
+	// calculate client area without scrollbar
+	cx = DGrid->Width;
+	cy = DGrid->Height;
+	cx -= (unsigned int)::GetSystemMetrics(SM_CXEDGE) * 2;
+	cy -= (unsigned int)::GetSystemMetrics(SM_CYEDGE) * 2;
+
+	// subtract scrollbar size
+	if (cx >= SubjectWidth)
+	{
+		if (cy < SubjectHeight)
+		{
+			cx -= ::GetSystemMetrics(SM_CXVSCROLL);
+			if (cx < SubjectWidth)
+				goto SUBTRACT_CYHSCROLL;
+		}
+		uShow = 0;
+	}
+	else
+	{
+	SUBTRACT_CYHSCROLL:
+		cx = SubjectWidth;
+		cy -= ::GetSystemMetrics(SM_CYHSCROLL);
+		uShow = SB_HORZ + 1;
+	}
+
+	// filling free space by last row
+	if (cy >= SubjectHeight)
+	{
+		DGrid->TopRow = 0;
+		FillHeight = cy - SubjectHeight;
+	}
+	else
+	{
+		FillHeight = RowHeight + cy % RowHeight;
+		uShow |= SB_VERT + 1;
+	}
+	DGrid->RowHeights[SubjectCount] = FillHeight;
+
+	assert(SB_HORZ + 1 == 1);
+	assert(SB_VERT + 1 == 2);
+	assert(SB_BOTH     == 3);
+
+	// update scroll bar
+	uHide = ~uShow;
+	if (uHide &= SB_BOTH)
+		::ShowScrollBar(DGridHandle, uHide - (uHide != SB_BOTH), FALSE);
+	if (uShow)
+		::ShowScrollBar(DGridHandle, uShow - (uShow != SB_BOTH), TRUE);
+
+	// resume redraw
+	::SendMessageA(DGridHandle, WM_SETREDRAW, TRUE, 0);
+
+	// update control once by DefaultColWidth
+	DGrid->DefaultColWidth = cx;
+
+	// restore cursor
+	EndWaitCursor();
+
+	// restore static flag
+	InProcessing = FALSE;
+#endif
 }
 //---------------------------------------------------------------------------
 //「電卓の10/16進変換関数」
@@ -1993,6 +3467,9 @@
 
  ssgCtrl.GetMemo()->clear();
  ssgCtrl.SetSSGActionListner(NULL);	//SSG展開時はガイドOFF
+#if defined(FIX_DGRID) && FIX_DGRID
+ nowSelectSubjectIndex = -2;
+#endif
  ssgCtrl.OpenSSG(&selectScript);
  ssgCtrl.SetSSGActionListner(&ssgActionListner);
  searchForm->Clear();
@@ -2087,6 +3564,16 @@
 //---------------------------------------------------------------------------
 //「メニューの、カスタマイズクリックイベント」
 //---------------------------------------------------------------------------
+#if defined(FIX_DGRID) && FIX_DGRID
+void __fastcall TMainForm_M_CustomizeClick_RedrawCalcImage(TMainForm *_this)
+{
+	_this->calcImage->SetStatus(18, _this->calcImage->GetStatus(18) + (_this->GetIsCalcHex() ? 0 : bsPUSHED));
+	_this->calcImage->DrawBtn(18, false);
+	if (_this->nowPanelType == ssgCtrl::atLONG || _this->nowPanelType == ssgCtrl::atDOUBLE)
+		_this->SubjectAccess(_this->selectSubject);
+}
+//---------------------------------------------------------------------------
+#endif
 void __fastcall TMainForm::M_CustomizeClick(TObject *Sender)
 {
  TCustomizeForm *tmpForm = new TCustomizeForm(this);
@@ -2217,9 +3704,14 @@
 
         calcFreeName = FreeName;
         calcPushName = PushName;
+#if defined(FIX_DGRID) && FIX_DGRID
+		TMainForm_M_CustomizeClick_RedrawCalcImage(this);
+#endif
     }
     CheckTreeSize(true);
+#if !defined(FIX_DGRID) || !FIX_DGRID
     DrawTree();
+#endif
  }
  delete tmpForm;
  HotKeyEdit->SetFocus();
@@ -2888,6 +4380,11 @@
 
 }
 //---------------------------------------------------------------------------
-
+void __fastcall TMainForm::SplitterMoved(TObject *Sender)
+{
+#if defined(FIX_DGRID) && FIX_DGRID
+	CheckTreeSize(true);
+#endif
+}
 //---------------------------------------------------------------------------
 
