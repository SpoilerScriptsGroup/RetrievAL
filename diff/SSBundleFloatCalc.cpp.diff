--- spal60sr\src\TSSGCtrl\SSBundleFloatCalc.original.cpp	Sun Apr  6 21:44:04 2003
+++ spal60sr\src\TSSGCtrl\SSBundleFloatCalc.cpp.txt	Sun Apr  6 21:44:04 2003
@@ -1,5 +1,20 @@
 #include "SSBundleFloatCalc.h"
 #include "BitOperation.h"
+
+#define LOCAL_MEMORY_SUPPORT 1
+#define FORCE_FUNNEL         1
+#define MIN_MAX_SUPPORT      1
+
+#if MIN_MAX_SUPPORT
+#include <float.h>
+#include "intrinsic.h"
+#endif
+
+#if LOCAL_MEMORY_SUPPORT
+unsigned long __stdcall TSSGCtrl_Read_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD *Address, vector<TProcessAccessElementBase*> &AEVec, const string &AddressStr);
+BOOLEAN __stdcall TSSGCtrl_OneWrite_with_CheckLocalMemory(TSSGCtrl *_this, TSSGSubject *SSGS, HANDLE ProcessHandle, DWORD Address, LPVOID Data, DWORD Size, const string &AddressStr);
+#endif
+
 //---------------------------------------------------------------------
 //「初期設定関数」
 //
@@ -33,6 +48,19 @@
 	else			size=8;
  }
  
+#if MIN_MAX_SUPPORT
+ if (tmpV[3].length() == 3)
+	if (*(LPDWORD)tmpV[3].begin() == BSWAP32('min\0'))
+		min = size == 8 ? DBL_MIN : FLT_MIN;
+	else if (*(LPDWORD)tmpV[3].begin() == BSWAP32('max\0'))
+		min = size == 8 ? DBL_MAX : FLT_MAX;
+ if (tmpV[4].length() == 3)
+	if (*(LPDWORD)tmpV[4].begin() == BSWAP32('min\0'))
+		max = size == 8 ? DBL_MIN : FLT_MIN;
+	else if (*(LPDWORD)tmpV[4].begin() == BSWAP32('max\0'))
+		max = size == 8 ? DBL_MAX : FLT_MAX;
+#endif
+
  isBigEndian = (tmpV[6]=="big_e");
 
  
@@ -61,14 +89,26 @@
  Setting(SSGC);
  
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ) )==NULL)
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
+#else
+ SHandle = SSGC.Open(this, PROCESS_VM_READ);
+#endif
 
+#if !SUBJECT_STATUS
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#else
+ if(!SSGC.IsEnabled(this, TRUE)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
+#endif
 
 
  //オフセット用のアドレスには、[replace]等の属性を付けない
+#if !SUBJECT_STATUS
  unsigned long Address = (isOffset)?SSGC.GetAddress(this, addressStr, 0):0;
+#else
+ unsigned long Address = (isOffset) ? (unsigned long)(address = (const BYTE *)SSGC.GetAddress(this, addressStr, 0)) : 0;
+#endif
 
  if(size==0)	//Setting()中ではファイルが開けなかった
 	return ssgCtrl::reOPTION_ERROR;	//リストファイルがない！
@@ -91,9 +131,16 @@
 	for(; VIt!=VEnd; VIt++){
 		if(VIt->empty()) continue;
 	
+#if !LOCAL_MEMORY_SUPPORT
 		ThisAddress = Address+SSGC.GetAddress(this, SSGC.strD.Get(*VIt,",",0));
 
 		if(SSGC.Read(this, SHandle, &ThisAddress, AEVec)!=0) 
+#else
+		string addressStr(SSGC.strD.Get(*VIt, ",", 0));
+		ThisAddress = Address + SSGC.GetAddress(this, addressStr);
+
+		if (TSSGCtrl_Read_with_CheckLocalMemory(&SSGC, this, SHandle, &ThisAddress, AEVec, addressStr) != 0)
+#endif
 			return ssgCtrl::reACCESS_ERROR;	//エラーなら1を返す
 		memcpy(&Val, AE.GetData()->begin(), size );
 
@@ -132,14 +179,22 @@
  Setting(SSGC);
 
  TSmartHandle SHandle;
+#if !LOCAL_MEMORY_SUPPORT
  if(( SHandle=SSGC.Open(this, PROCESS_VM_READ|PROCESS_VM_WRITE|PROCESS_VM_OPERATION) )==NULL)
 	return ssgCtrl::reOPEN_ERROR;	//プロセスのオープンエラー
+#else
+ SHandle = SSGC.Open(this, PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION);
+#endif
 
  if(!SSGC.IsEnabled(this)) return ssgCtrl::reNOT_ENABLED;	//有効条件が偽
 
 
  //オフセット用のアドレスには、[replace]等の属性を付けない
+#if !SUBJECT_STATUS
  unsigned long Address = (isOffset)?SSGC.GetAddress(this, addressStr, 0):0;
+#else
+ unsigned long Address = (isOffset) ? (unsigned long)(address = (const BYTE *)SSGC.GetAddress(this, addressStr, 0)) : 0;
+#endif
 
  vector<string> *ListFile = SSGC.GetSSGDataFile(this, fileName, ".CHN");
  if(ListFile==NULL) return ssgCtrl::reOPTION_ERROR;	//チェインファイルがない！
@@ -159,9 +214,16 @@
 		for(; VIt!=VEnd; VIt++){
 			if(VIt->empty()) continue;
 
+#if !LOCAL_MEMORY_SUPPORT
 			ThisAddress = Address+SSGC.GetAddress(this, SSGC.strD.Get(*VIt,",",0));
 
 			if( !SSGC.OneWrite(this, SHandle, ThisAddress, &Val2, size) ){
+#else
+			string addressStr(SSGC.strD.Get(*VIt, ",", 0));
+			ThisAddress = Address + SSGC.GetAddress(this, addressStr);
+
+			if (!TSSGCtrl_OneWrite_with_CheckLocalMemory(&SSGC, this, SHandle, ThisAddress, &Val2, size, addressStr)) {
+#endif
 				//エラーならssgCtrl::reACCESS_ERRORを返す
 				return ssgCtrl::reACCESS_ERROR;
 			}
@@ -173,8 +235,14 @@
 		for(; VIt!=VEnd; VIt++){
 			if(VIt->empty()) continue;
 
+#if !LOCAL_MEMORY_SUPPORT
 			ThisAddress = Address+SSGC.GetAddress(this, SSGC.strD.Get(*VIt,",",0));
 			if( !SSGC.OneWrite(this, SHandle, ThisAddress, &Val2, size) ){
+#else
+			string addressStr(SSGC.strD.Get(*VIt, ",", 0));
+			ThisAddress = Address + SSGC.GetAddress(this, addressStr);
+			if (!TSSGCtrl_OneWrite_with_CheckLocalMemory(&SSGC, this, SHandle, ThisAddress, &Val2, size, addressStr)) {
+#endif
 				//エラーならssgCtrl::reACCESS_ERRORを返す
 				return ssgCtrl::reACCESS_ERROR;
 			}
@@ -182,8 +250,9 @@
 	}
  }
 
- //SSGC.CheckFunnel(this, Val);
-
+#if FORCE_FUNNEL
+ SSGC.CheckFunnel(this, 0);
+#endif
  return ssgCtrl::reNO_ERROR;
 }
 //---------------------------------------------------------------------
