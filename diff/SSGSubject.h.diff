--- spal60sr\src\TSSGCtrl\SSGSubject.original.h	Sun Apr  6 21:46:46 2003
+++ spal60sr\src\TSSGCtrl\SSGSubject.h	Sun Apr  6 21:46:46 2003
@@ -3,6 +3,14 @@
 
 #pragma warning(disable:4786)
 #include "SmartVector.h"
+
+#define FIX_DGRID            1
+#define REPEAT_INDEX         1
+#define IO_FEP_SUPPORT       1
+#define SUBJECT_STATUS       1
+#define SUBJECT_STRING_TABLE 1
+#define LOCAL_MEMORY_SUPPORT 1
+
 //---------------------------------------------------------------------
 //「定数一覧」
 //---------------------------------------------------------------------
@@ -50,6 +58,61 @@
 //---------------------------------------------------------------------
 //「クラス宣言」
 //---------------------------------------------------------------------
+#if SUBJECT_STRING_TABLE
+class CUniqueStringTable
+{
+public:
+	CUniqueStringTable()
+	{
+		initialize();
+	}
+private:
+	void initialize()
+	{
+		array.resize(1);
+		indices.push_back(0);
+	}
+public:
+	void clear()
+	{
+		vector<size_t>().swap(indices);
+		vector<string>().swap(array);
+		initialize();
+	}
+	size_t insert(const char *s)
+	{
+		if (!s || !*s)
+			return 0;
+		size_t middle = 1;
+		size_t low = 1;
+		size_t high = indices.size() - 1;
+		while (low <= high)
+		{
+			middle = (low + high) / 2;
+			int cmp = strcmp(array[indices[middle]].c_str(), s);
+			if (!cmp)
+				return indices[middle];
+			if (cmp < 0)
+				low = middle + 1;
+			else
+				high = middle - 1;
+		}
+		array.push_back(s);
+		size_t index = indices.size();
+		indices.insert(indices.begin() + middle, index);
+		return index;
+	}
+	string& operator [](size_t index)
+	{
+		return array[index];
+	}
+private:
+	vector<string> array;
+	vector<size_t> indices;
+};
+extern CUniqueStringTable SubjectStringTable;
+//---------------------------------------------------------------------
+#endif
 class TSSGCtrl;
 class TSSGAttributeElement;
 class TAdjustmentAttribute;
@@ -62,11 +125,102 @@
 
 	vector<TSSGAttributeElement *> *attribute;	//適用される属性
 	byte status;	//ロックや展開済みなどのフラグ
+#if IO_FEP_SUPPORT
+public:
+	BOOLEAN isFEP;
+protected:
+#endif
+#if SUBJECT_STATUS
+public:
+	BOOLEAN evaluateAtRead;
+protected:
+#endif
+#if REPEAT_INDEX
+public:
+	DWORD propertyIndex;
+protected:
+#endif
+#if !SUBJECT_STRING_TABLE
 	string name;	//項目名（/区切り等含む全て）
 	string code;	//項目名以外のコード
 	string subjectName; //純粋な項目名
+#else
+	class CTableReferencedString
+	{
+	public:
+		CTableReferencedString() : reserved1(0), reserved2(0), index(0), reserved3(0), reserved4(0), reserved5(0)
+		{
+		}
+		operator string&() const
+		{
+			return SubjectStringTable[index];
+		}
+		CTableReferencedString& operator =(const string& s)
+		{
+			return *this = s.c_str();
+		}
+		CTableReferencedString& operator =(const string s)
+		{
+			return *this = s.c_str();
+		}
+		CTableReferencedString& operator =(const char *s)
+		{
+			index = SubjectStringTable.insert(s);
+			return *this;
+		}
+		size_t size()
+		{
+			return SubjectStringTable[index].size();
+		}
+		size_t length()
+		{
+			return SubjectStringTable[index].length();
+		}
+		bool empty()
+		{
+			return SubjectStringTable[index].empty();
+		}
+		const char *c_str()
+		{
+			return SubjectStringTable[index].c_str();
+		}
+		string operator +(const string& s)
+		{
+			return SubjectStringTable[index] + s;
+		}
+		friend string operator +(const string& left, const CTableReferencedString& right)
+		{
+			return left + SubjectStringTable[right.index];
+		}
+		friend string operator +(const char *left, const CTableReferencedString& right)
+		{
+			return left + SubjectStringTable[right.index];
+		}
+		bool operator !=(const char *s)
+		{
+			return SubjectStringTable[index] != s;
+		}
+	private:
+		size_t reserved1;
+		size_t reserved2;
+		size_t index;
+		size_t reserved3;
+		size_t reserved4;
+		size_t reserved5;
+	};
+	CTableReferencedString name;
+	CTableReferencedString code;
+	CTableReferencedString subjectName;
+#endif
 public:
+#if SUBJECT_STATUS
+	const BYTE *address;
+#endif
+#if !REPEAT_INDEX
     TSSGSubject(void) :isSeted(false), status(0), attribute(NULL){ type=ssgCtrl::stNONE; }
+#else
+	TSSGSubject();
+#endif
     virtual ~TSSGSubject(){}
 
 	void ReSetting(TSSGCtrl &SSGC){ isSeted=false; Setting(SSGC); }
@@ -96,9 +250,17 @@
     virtual unsigned long Write(TSSGCtrl &SSGC, TSSArg *Arg){ return 0; }
 	virtual string ToString(TSSGCtrl &SSGC){ return "[subject]"+name+":"+code; }
 	virtual string ToByteCode(TSSGCtrl &SSGC, TSSArg *Val){ return (string)""; }
+#if !SUBJECT_STRING_TABLE
     virtual string GetLockName(void){ return string(); }
+#else
+	virtual string& GetLockName(void) const { return SubjectStringTable[0]; }
+#endif
 	virtual unsigned long GetSize(void){ return 0; }
+#if !SUBJECT_STRING_TABLE
 	virtual string GetAddressStr(void){ return string(); }
+#else
+	virtual string& GetAddressStr(void) const { return SubjectStringTable[0]; }
+#endif
 	virtual unsigned long GetArgType(void){ return ssgCtrl::atUNKNOWN; }
 	virtual bool IsSameSubject(TSSGSubject *SSGS){ return false; }
 };
